<div id="maincontent">
<div id="midcolumn">
<h1>Delegation Operations</h1>

<p>
Delegation operations move features along the delegation structure.
</p>


<h2 id="collectFeature">Collect Feature over Reference</h2>
<p>
In the metamodel, a feature is moved opposite to a multi-valued reference. In the model, the values of the feature are aggregated accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>feature</tt>: The feature to be moved</li>
	<li><tt>reference</tt>: The reference opposite to which the feature is moved</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>Both feature and reference must be multi-valued or the reference must be single-valued</li>
	<li>The feature must belong to the reference's type</li>
</ul>
</p>


<h2 id="combineFeature">Combine Features over References</h2>
<p>
In the metamodel, a number of features are combined in to a single feature by moving it over references to the same class. In the model, the values of the features are moved accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>features</tt>: The features to be combined</li>
	<li><tt>references</tt>: The references over which the features are moved (in the same order)</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>There must be an equal number of features and references</li>
	<li>All references must have the same class as type</li>
	<li>Each feature has to belong to its reference's class</li>
</ul>
</p>


<h2 id="extractAndGroupAttribute">Extract and Group Attribute</h2>
<p>
In the metamodel, an attribute is extracted into a new class. This extracted class is contained by an existing container class and referenced from the context class. In the model, an instance of the extracted class is created for each different value of the extracted attribute.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>extractedAttribute</tt>: The attribute to be extracted</li>
	<li><tt>contextPackage</tt>: The package in which the extracted class is created</li>
	<li><tt>extractedClassName</tt>: The name of the extracted class</li>
	<li><tt>referenceName</tt>: The reference from the context class to the extracted class</li>
	<li><tt>containerClass</tt>: The container class for the extracted class</li>
	<li><tt>containerReferenceName</tt>: The name of the containment reference from the container class to the extracted class</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The extracted attribute must be single-valued</li>
</ul>
</p>


<h2 id="extractClass">Extract Class</h2>
<p>
In the metamodel, a number of features are extracted to a new class. This new class is accessible from the context class through a new containment reference. In the model, the values of the features are extracted to a new instance accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>contextClass</tt>: The context class from which the features are extracted</li>
	<li><tt>features</tt>: The features to be extracted</li>
	<li><tt>ePackage</tt>: The package in which the extracted class is created</li>
	<li><tt>className</tt>: The name of the extracted class</li>
	<li><tt>referenceName</tt>: The name of the new containment reference from context to extracted class</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The features have to belong to the same class</li>
	<li>A classifier with the same name already exists</li>
	<li>A feature with the same name already exists</li>
</ul>
</p>


<h2 id="extractExistingClass">Fold Class</h2>
<p>
In the metamodel, a number of features are extracted into an existing class. More specifically, a containment reference to the extracted class is created and the features are replaced by features of the extracted class. In the model, the values of the features are moved accordingly to a new instance of the extracted class.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>toReplace</tt>: The features to be extracted</li>
	<li><tt>extractedClass</tt>: The extracted class</li>
	<li><tt>replaceBy</tt>: The features of the extracted class by which they are replaced (in the same order)</li>
	<li><tt>referenceName</tt>: The name of the containment reference</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The features must be of the same type</li>
	<li>The features to replace must be defined in the extracted class</li>
	<li>The replaced and replacing features must be of the same size</li>
	<li>The features must be of the same multiplicity</li>
</ul>
</p>


<h2 id="flattenHierarchy">Flatten Containment Hierarchy</h2>
<p>
In the metamodel, a containment hierarchy is flattened. More specifically, the reference to denote the root as well as the reference to denote the children are replaced by a containment reference. In the model, the corresponding hierarchies are flattened accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>rootReference</tt>: The reference to denote the root node</li>
	<li><tt>childrenReference</tt>: The reference to denote the children nodes</li>
	<li><tt>referenceName</tt>: The reference which replaces the containment hierarchy</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The type of the children reference must be the node class.</li>
	<li>The root reference must be a single-valued containment reference.</li>
	<li>The children reference must be defined by the node class.</li>
	<li>The children reference must be a multi-valued containment reference.</li>
</ul>
</p>


<h2 id="inlineClass">Inline Class</h2>
<p>
In the metamodel, a class reachable through a single-valued containment reference is inlined. More specifically, its features are moved to the source class of the reference. In the model, the values of these features are moved accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>reference</tt>: The reference to the class to be inlined</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The multiplicity of the reference must be single-valued</li>
	<li>The class to be inlined must not have sub classes</li>
	<li>The reference must not have an opposite</li>
	<li>The reference must be containment</li>
	<li>The class to be inlined must not be a type of another reference</li>
</ul>
</p>


<h2 id="moveFeature">Move Feature along Reference</h2>
<p>
In the metamodel, a feature is moved along a single-valued reference. In the model, values are moved accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>feature</tt>: The feature to be moved</li>
	<li><tt>reference</tt>: The reference along which the feature is moved</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The multiplicity of the reference must be single-valued and obligatory</li>
	<li>The reference must be available in the same class as the feature</li>
	<li>The multiplicity of its opposite reference must be single-valued</li>
	<li>A feature with that name already exists in the target class</li>
</ul>
</p>


<h2 id="partitionComposite">Introduce Composite Pattern</h2>
<p>
In the metamodel, the composite design pattern is introduced. More specifically, a class is refined by two sub classes - one for composite and one for leaf elements, and a reference is moved to the composite class. In addition, the class is made abstract. In the model, instances of that class are migrated based on whether the reference is populated or not.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>eClass</tt>: The class which is refined</li>
	<li><tt>compositeName</tt>: The name of the composite class</li>
	<li><tt>leafName</tt>: The name of the leaf class</li>
	<li><tt>childReference</tt>: The reference for composite elements</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The class must not have sub classes</li>
	<li>The child reference must be a containment reference</li>
	<li>The child reference must be defined by the class</li>
</ul>
</p>


<h2 id="propagateFeature">Propagate Feature over References</h2>
<p>
In the metamodel, a feature is propagated opposite to a number of references. More specifically, the feature is created in each of the classes which are sources of the references. In the model, the values of that feature are moved accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>mainFeature</tt>: The feature to be propagated</li>
	<li><tt>references</tt>: The references opposite to which the feature is propagated</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>Every reference has to target the class with the feature</li>
</ul>
</p>


<h2 id="unfoldClass">Unfold Class</h2>
<p>
In the metamodel, a class reachable through a single-valued containment reference is unfolded. More specifically, its features are copied to the source class of the reference which is deleted. In the model, the values of these features are moved accordingly.
</p>

<p><h5>Parameters:</h5>
<ul>
	<li><tt>reference</tt>: The reference to the class to be unfolded</li>
</ul>
</p>

<p>
<h5>Constraints:</h5>
<ul>
	<li>The multiplicity of the reference must be single-valued</li>
	<li>The class to be unfolded must not have sub classes</li>
	<li>The reference must not have an opposite</li>
	<li>The reference must be containment</li>
</ul>
</p>




</div>

<div id="rightcolumn">
<div class="sideitem">
<div class="modal">
<h6>Contents</h6>
	<ul>
		  <li><a href="org.eclipse.emf.edapt.declaration.creation.StructuralPrimitives.php">Structural Primitives</a></li>
		  <li><a href="org.eclipse.emf.edapt.declaration.simple.NonStructuralPrimitives.php">Non-structural Primitives</a></li>
		  <li><a href="org.eclipse.emf.edapt.declaration.generalization.GeneralizationOperations.php">Generalization / Specialization Operations</a></li>
		  <li><a href="org.eclipse.emf.edapt.declaration.inheritance.InheritanceOperations.php">Inheritance Operations</a></li>
		  <li><a href="org.eclipse.emf.edapt.declaration.delegation.DelegationOperations.php">Delegation Operations</a></li>
				<ul>
	<li><a href="#collectFeature">Collect Feature over Reference</a></li>
	<li><a href="#combineFeature">Combine Features over References</a></li>
	<li><a href="#extractAndGroupAttribute">Extract and Group Attribute</a></li>
	<li><a href="#extractClass">Extract Class</a></li>
	<li><a href="#extractExistingClass">Fold Class</a></li>
	<li><a href="#flattenHierarchy">Flatten Containment Hierarchy</a></li>
	<li><a href="#inlineClass">Inline Class</a></li>
	<li><a href="#moveFeature">Move Feature along Reference</a></li>
	<li><a href="#partitionComposite">Introduce Composite Pattern</a></li>
	<li><a href="#propagateFeature">Propagate Feature over References</a></li>
	<li><a href="#unfoldClass">Unfold Class</a></li>
				</ul>
		  <li><a href="org.eclipse.emf.edapt.declaration.replacement.ReplacementOperations.php">Replacement Operations</a></li>
		  <li><a href="org.eclipse.emf.edapt.declaration.merge.MergeOperations.php">Merge Operations</a></li>
	</ul>
</div>
</div>
</div>

</div>
